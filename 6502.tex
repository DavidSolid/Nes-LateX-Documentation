\documentclass{article}
\usepackage{amsmath}
\usepackage{float}
\usepackage{longtable}
\usepackage{multicol}
\usepackage{moreenum}
\title{6502 Microprocessor}
\author{DavidSolid (LateX document), Unknown (Original)}
\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Introduction}
 Most of the following information has been taking out of the "Commodore 64
Programmers Reference Manual" simply because it was available in electronic
form and there appears to be no difference between this documentation and
the 6502 documentation, they are both from the 6500 family after all. I've
made changes and additions where appropriate.

 In theory you should be able to use any code you can find for emulating
the 6510 (the C64 processor).

\section{Registers}

Almost all calculations are done in the microprocessor. Registers are
special pieces of memory in the processor which are used to carry out, and
store information about calculations. The 6502 has the following registers:


  \subsection{Accumulator (A)}

    This is \textbf{the most important register} in the microprocessor. Various ma-
  chine language instructions allow you to copy the contents of a memory
  location into the accumulator, copy the contents of the accumulator into
  a memory location, modify the contents of the accumulator or some other
  register directly, without affecting any memory. And the accumulator is
  the only register that has instructions for performing math.


  \subsection{X Index Register}

    This is a very important register. There are instructions for nearly
  all of the transformations you can make to the accumulator. But there are
  other instructions for things that only the X register can do. Various
  machine language instructions allow you to copy the contents of a memory
  location into the X register, copy the contents of the X register into a
  memory location, and modify the contents of the X, or some other register
  directly.


  \subsection{Y Index Register}

    This is a very important register. There are instructions for nearly
  all of the transformations you can make to the accumulator, and the X
  register. But there are other instructions for things that only the Y
  register can do. Various machine language instructions allow you to copy
  the contents of a memory location into the Y register, copy the contents
  of the Y register into a memory location, and modify the contents of the
  Y, or some other register directly.


  \subsection{Status register}

    This register consists of eight "flags" (a flag = something that indi-
  cates whether something has, or has not occurred). Bits of this register
  are altered depending on the result of arithmetic and logical operations.
  These bits are described below:

  \begin{table}[h!]
  \centering
  \begin{tabular}{c c c c c c c c c}
    Bit No. & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
    \hline
    Simbols & S & V &   & B & D & I & Z & C \\
  \end{tabular}
  \caption{Status register layout}
  \end{table}
  \begin{itemize}
   \item Bit 0 - C - Carry flag: this holds the carry out of the most significant
   bit in any arithmetic operation. In subtraction operations however, this
   flag is cleared - set to 0 - if a borrow is required, set to 1 - if no
   borrow is required. The carry flag is also used in shift and rotate
   logical operations.

   \item Bit 1 - Z - Zero flag: this is set to 1 when any arithmetic or logical
   operation produces a zero result, and is set to 0 if the result is
   non-zero.

   \item Bit 2 - I: this is an interrupt enable/disable flag. If it is set,
   interrupts are disabled. If it is cleared, interrupts are enabled.

   \item Bit 3 - D: this is the decimal mode status flag. When set, and an Add with
   Carry or Subtract with Carry instruction is executed, the source values are
   treated as valid BCD (Binary Coded Decimal, eg. 0x00-0x99 = 0-99) numbers.
   The result generated is also a BCD number.

   \item Bit 4 - B: this is set when a software interrupt (BRK instruction) is
   executed.

   \item Bit 5: not used. Supposed to be logical 1 at all times.

   \item Bit 6 - V - Overflow flag: when an arithmetic operation produces a result
   too large to be represented in a byte, V is set.

   \item Bit 7 - S - Sign flag: this is set if the result of an operation is
   negative, cleared if positive.
  \end{itemize}

   The most commonly used flags are C, Z, V, S.

  

  \subsection{Program Counter}

    This contains the address of the current machine language instruction
  being executed. Since the operating system is always "RUN"ning in the
  Commodore VIC-20 (or, for that matter, any computer), the program counter
  is always changing. It could only be stopped by halting the microprocessor
  in some way.


  \subsection{Stack pointer}

    This register contains the location of the first empty place on the
  stack. The stack is used for temporary storage by machine language pro-
  grams, and by the computer.




  \section{Addressing Modes}

   Instructions need operands to work on. There are various ways of
  indicating where the processor is to get these operands. The different
  methods used to do this are called addressing modes. The 6502 offers 11
  modes, as described below.
  \subsection{Immediate}
  In this mode the operand's value is given in the instruction itself. In
  assembly language this is indicated by "\#" before the operand.
  eg.  LDA \#\$0A - means "load the accumulator with the hex value 0A"
  In machine code different modes are indicated by different codes. So LDA
  would be translated into different codes depending on the addressing mode.
  In this mode, it is: \$A9 \$0A

  \subsection{Absolute and Zero-page Absolute}
  In these modes the operands address is given.
  eg.  LDA \$31F6 - (assembler)
       \$AD \$31F6 - (machine code)
  If the address is on zero page - i.e. any address where the high byte is
  00 - only 1 byte is needed for the address. The processor automatically
  fills the 00 high byte.
  eg.  LDA \$F4
       \$A5 \$F4
  Note the different instruction codes for the different modes.
  Note also that for 2 byte addresses, the low byte is store first, eg.
  LDA \$31F6 is stored as three bytes in memory, \$AD \$F6 \$31.
  Zero-page absolute is usually just called zero-page.

  \subsection{Implied}
  No operand addresses are required for this mode. They are implied by the
  instruction.
  eg.  TAX - (transfer accumulator contents to X-register)
       \$AA

  \subsection{Accumulator}
  In this mode the instruction operates on data in the accumulator, so no
  operands are needed.
  eg.  LSR - logical bit shift right
       \$4A

  \subsection{Indexed and Zero-page Indexed}
  In these modes the address given is added to the value in either the X or
  Y index register to give the actual address of the operand.
  eg.  LDA \$31F6, Y
       \$D9 \$31F6
       LDA \$31F6, X
       \$DD \$31F6
  Note that the different operation codes determine the index register used.
  In the zero-page version, you should note that the X and Y registers are
  not interchangeable. Most instructions which can be used with zero-page
  indexing do so with X only.
  eg.  LDA \$20, X
       \$B5 \$20

  \subsection{Indirect}
  This mode applies only to the JMP instruction - JuMP to new location. It is
  indicated by parenthesis around the operand. The operand is the address of
  the bytes whose value is the new location.
  eg.  JMP (\$215F)
  Assume the following -

  \begin{table}[h!]
  \centering
  \begin{tabular}{|c c|}
  \hline        
  byte   &  value \\
  \hline
  \$215F  &  \$76 \\
  \$2160  &  \$30 \\
  \hline
  \end{tabular}
  \end{table}

  This instruction takes the value of bytes \$215F, \$2160 and uses that as the
  address to jump to - i.e. \$3076 (remember that addresses are stored with
  low byte first).

  \subsection{Pre-indexed indirect}
  In this mode a zer0-page address is added to the contents of the X-register
  to give the address of the bytes holding the address of the operand. The
  indirection is indicated by parenthesis in assembly language.
  eg.  LDA (\$3E, X)
       \$A1 \$3E
  Assume the following -

  \begin{table}[h!]
  \centering
  \begin{tabular}{|c c|}
  \hline        
  byte   &  value \\
  \hline
  X-reg.  & \$05 \\
  \$0043  &  \$15 \\
  \$0044  &  \$24 \\
  \$2415  &  \$6E \\
  \hline
  \end{tabular}
  \end{table}

  Then the instruction is executed by:
  \begin{enumerate}
  \item   adding \$3E and \$05 = \$0043
  \item  getting address contained in bytes \$0043, \$0044 = \$2415
  \item loading contents of \$2415 - i.e. \$6E - into accumulator

  \item Note
  %\renewcommand{\theenumi}{\alph(enumi)}
  \begin{enumerate} 
  \item When adding the 1-byte address and the X-register, wrap around
        addition is used - i.e. the sum is always a zero-page address.
        eg. FF + 2 = 0001 not 0101 as you might expect.
        DON'T FORGET THIS WHEN EMULATING THIS MODE.
  \item Only the X register is used in this mode.
  \end{enumerate}
  \end{enumerate}

  \subsection{Post-indexed indirect}
  In this mode the contents of a zero-page address (and the following byte)
  give the indirect addressm which is added to the contents of the Y-register
  to yield the actual address of the operand. Again, inassembly language,
  the instruction is indicated by parenthesis.
  eg.  LDA (\$4C), Y
  Note that the parenthesis are only around the 2nd byte of the instruction
  since it is the part that does the indirection.
  Assume the following -

  \begin{table}[h!]
  \centering
  \begin{tabular}{|c c|}
  \hline       
  byte   &   value \\
  \hline
  \$004C   &  \$00 \\
  \$004D   &  \$21 \\
  Y-reg.  &  \$05 \\
  \$2105   &  \$6D \\
  \hline
  \end{tabular}
  \end{table}

  Then the instruction above executes by:
  \begin{enumerate}
  \item   getting the address in bytes \$4C, \$4D = \$2100
  \item  adding the contents of the Y-register = \$2105
  \item loading the contents of the byte \$2105 - i.e. \$6D into the
        accumulator.
  \end{enumerate}
  Note: only the Y-register is used in this mode.

  \subsection{Relative}
  This mode is used with Branch-on-Condition instructions. It is probably
  the mode you will use most often. A 1 byte value is added to the program
  counter, and the program continues execution from that address. The 1
  byte number is treated as a signed number - i.e. if bit 7 is 1, the number
  given byt bits 0-6 is negative; if bit 7 is 0, the number is positive. This
  enables a branch displacement of up to 127 bytes in either direction.

  \begin{table}[h!]
  \centering
  \caption{Example}
  \begin{tabular}{|c|c c c c c c c c|c|c|}
  \hline
  bit no. & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0  &  signed value     &     unsigned value \\
  \hline
  value  &  1 & 0 & 1 & 0 & 0 & 1 & 1 & 1  &  -39          &         \$A7 \\
  value  &  0 & 0 & 1 & 0 & 0 & 1 & 1 & 1  &  +39          &         \$27 \\
  \hline
  \end{tabular}
  \end{table}

  Instruction example:
    BEQ \$A7
    \$F0 \$A7
  This instruction will check the zero status bit. If it is set, 39 decimal
  will be subtracted from the program counter and execution continues from
  that address. If the zero status bit is not set, execution continues from
  the following instruction.
  Notes:
  \begin{enumerate}
    \item The program counter points to the start of the instruction
  after the branch instruction before the branch displacement is added.
  Remember to take this into account when calculating displacements.
    \item Branch-on-condition instructions work by checking the relevant
  status bits in the status register. Make sure that they have been set or
  unset as you want them. This is often done using a CMP instruction.
    \item If you find you need to branch further than 127 bytes, use the
  opposite branch-on-condition and a JMP.
  \end{enumerate}
  \section{Instruction Set}
  \begin{longtable}{|c c|}

  \hline
  \multicolumn{2}{|c|}{MCS6502 MICROPROCESSOR INSTRUCTION SET - ALPHABETIC SEQUENCE}\\
  \hline
  Mnemonic & Description \\
  \hline
  \endfirsthead

  \hline
  \endhead

  \hline
  \multicolumn{2}{|c|}{Continues in next page}\\
  \hline
  \endfoot

  \hline
  \caption{List of documented opcodes}
  \endlastfoot

  ADC & Add Memory to Accumulator with Carry \\
  AND & "AND" Memory with Accumulator \\
  ASL & Shift Left One Bit (Memory or Accumulator) \\
      & \\
  BCC & Branch on Carry Clear \\
  BCS & Branch on Carry Set \\
  BEQ & Branch on Result Zero \\
  BIT & Test Bits in Memory with Accumulator \\
  BMI & Branch on Result Minus \\
  BNE & Branch on Result not Zero \\
  BPL & Branch on Result Plus \\
  BRK & Force Break \\
  BVC & Branch on Overflow Clear \\
  BVS & Branch on Overflow Set \\
      & \\
  CLC & Clear Carry Flag \\
  CLD & Clear Decimal Mode \\
  CLI & Clear interrupt Disable Bit \\
  CLV & Clear Overflow Flag \\
  CMP & Compare Memory and Accumulator \\
  CPX & Compare Memory and Index X \\
  CPY & Compare Memory and Index Y \\
      & \\
  DEC & Decrement Memory by One \\
  DEX & Decrement Index X by One \\
  DEY & Decrement Index Y by One \\
      & \\
  EOR & "Exclusive-Or" Memory with Accumulator \\
      & \\
  INC & Increment Memory by One \\
  INX & Increment Index X by One \\
  INY & Increment Index Y by One \\
  JMP & Jump to New Location \\
  JSR & Jump to New Location Saving Return Address \\
      & \\
  LDA & Load Accumulator with Memory \\
  LDX & Load Index X with Memory \\
  LDY & Load Index Y with Memory \\
  LSR & Shift Right One Bit (Memory or Accumulator) \\
      & \\
  NOP & No Operation \\
      & \\
  ORA & "OR" Memory with Accumulator \\
      & \\
  PHA & Push Accumulator on Stack \\
  PHP & Push Processor Status on Stack \\
  PLA & Pull Accumulator from Stack \\
  PLP & Pull Processor Status from Stack \\
      & \\
  ROL & Rotate One Bit Left (Memory or Accumulator) \\
  ROR & Rotate One Bit Right (Memory or Accumulator) \\
  RTI & Return from Interrupt \\
  RTS & Return from Subroutine \\
      & \\
  SBC & Subtract Memory from Accumulator with Borrow \\
  SEC & Set Carry Flag \\
  SED & Set Decimal Mode \\
  SEI & Set Interrupt Disable Status \\
  STA & Store Accumulator in Memory \\
  STX & Store Index X in Memory \\
  STY & Store Index Y in Memory \\
      & \\
  TAX & Transfer Accumulator to Index X \\
  TAY & Transfer Accumulator to Index Y \\
  TSX & Transfer Stack Pointer to Index X \\
  TXA & Transfer Index X to Accumulator \\
  TXS & Transfer Index X to Stack Pointer \\
  TYA & Transfer Index Y to Accumulator \\ 
  \end{longtable}

  The following notation applies to this summary:
    \begin{table}[h!]
    \centering
    \begin{tabular}{|c c|c c|}
    \hline
    Symbol & Meaning                 &    Symbol & Meaning \\
    \hline
     A   &   Accumulator             &    EOR  &  Logical Exclusive Or \\
     X, Y  & Index Registers         &    fromS & Transfer from Stack \\
     M   &   Memory                  &    toS  &  Transfer to Stack \\
     P   &   Processor Status Register  & $\Rightarrow$   &  Transfer to \\
     S   &   Stack Pointer        &       $\Leftarrow$   &  Transfer from \\
     /   &   Change           &           $\lor$   &   Logical OR \\
     \_   &   No Change           &        PC   &  Program Counter \\
     +   &   Add             &            PCH  &  Program Counter High \\
     $\land$  &   Logical AND        &         PCL  &  Program Counter Low \\
     -   &   Subtract          &          OPER  & OPERAND \\
         &                 &              \#   &   IMMEDIATE ADDRESSING MODE \\
    \hline
  \end{tabular}
  \caption{Notation table}
  \end{table}

  Note: At the top of each table is located in parentheses a reference
        number (Ref: XX) which directs the user to that Section in the
        MCS6500 Microcomputer Family Programming Manual in which the
        instruction is defined and discussed.




  \subsection{ADC (Add memory to accumulator with carry)}

  Operation:  $A + M + C \implies A, C$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N & Z & C & I & D & V\\
  \hline
  / & / & / &\_ & \_ & /\\
  \hline
  \end{tabular}
  \end{table}
                                (Ref: 2.2.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
  Addressing Mode & Assembly Language Form & OP CODE & No. Bytes & No. Cycles\\
  \hline
  Immediate    &   ADC \#Oper        &      69   &   2    &    2\\
  Zero Page    &   ADC Oper         &      65   &   2    &    3\\     
  Zero Page,X  &   ADC Oper,X       &      75   &   2    &    4\\     
  Absolute     &   ADC Oper         &      60   &   3    &    4\\     
  Absolute,X   &   ADC Oper,X       &      70   &   3    &    4*\\    
  Absolute,Y   &   ADC Oper,Y       &      79   &   3    &    4*\\    
  (Indirect,X)  &  ADC (Oper,X)     &      61   &   2    &    6\\     
  (Indirect),Y  &  ADC (Oper),Y     &      71   &   2    &    5*\\    
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if page boundary is crossed.


  \subsection{AND ("AND" memory with accumulator)}

  Operation:  
  $A \land M \implies A$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  /&/&\_&\_&\_&\_\\
  \hline
  \end{tabular}
  \end{table}
                               (Ref: 2.2.3.0)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
  Addressing Mode & Assembly Language Form & OP CODE & No. Bytes & No. Cycles\\
  \hline
  Immediate    &   AND \#Oper           &    29   &    2    &    2     \\
  Zero Page    &   AND Oper            &    25   &    2    &    3     \\
  Zero Page,X  &   AND Oper,X          &    35   &    2    &    4     \\
  Absolute     &   AND Oper            &    2D   &    3    &    4     \\
  Absolute,X   &   AND Oper,X          &    3D   &    3    &    4*    \\
  Absolute,Y   &   AND Oper,Y          &    39   &    3    &    4*    \\
  (Indirect,X) &   AND (Oper,X)        &    21   &    2    &    6     \\
  (Indirect,Y) &   AND (Oper),Y        &    31   &    2    &    5     \\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if page boundary is crossed.


  \subsection{ASL (ASL Shift Left One Bit (Memory or Accumulator))}
  Operation:  $C \Leftarrow$ \begin{tabular}{|c|c|c|c|c|c|c|c|}\hline7&6&5&4&3&2&1&0\\\hline\end{tabular} $\Leftarrow 0$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  /&/&/&\_&\_&\_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 10.2)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
  Addressing Mode & Assembly Language Form & OP CODE & No. Bytes & No. Cycles\\
  \hline
  Accumulator   &   ASL A               &    0A   &    1    &    2\\
  Zero Page     &   ASL Oper            &    06   &    2    &    5\\
  Zero Page,X   &   ASL Oper,X          &    16   &    2    &    6\\
  Absolute      &   ASL Oper            &    0E   &    3    &    6\\
  Absolute, X   &   ASL Oper,X          &    1E   &    3    &    7\\
  \hline
  \end{tabular}
  \end{table}

  \subsection{BCC (Branch on Carry Clear)}
  Operation:  Branch on C = 0
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_&\_&\_&\_&\_&\_\\
  \hline
  \end{tabular}
  \end{table}
                               (Ref: 4.1.1.3)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
  Addressing Mode & Assembly Language Form & OP CODE & No. Bytes & No. Cycles\\
  \hline
  Relative      &   BCC Oper            &    90   &    2    &    2*\\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page.


  \subsection{BCS (BCS Branch on carry set)}

  Operation:  Branch on C = 1
  \begin{table}[H]
  \centering                           
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                               (Ref: 4.1.1.4)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
  Addressing Mode & Assembly Language Form & OP CODE & No. Bytes & No. Cycles\\
  \hline
  Relative      &   BCS Oper            &    B0   &    2    &    2*\\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if branch occurs to same  page.
  * Add 2 if branch occurs to next  page.


  \subsection{BEQ (BEQ Branch on result zero)}
  Operation:  Branch on Z = 1
  \begin{table}[H]
  \centering                           
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                               (Ref: 4.1.1.5)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
  Addressing Mode & Assembly Language Form & OP CODE & No. Bytes & No. Cycles\\
  \hline
  Relative    &   BEQ Oper            &    F0   &    2    &    2*\\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if branch occurs to same  page.
  * Add 2 if branch occurs to next  page.


  \subsection{BIT (BIT Test bits in memory with accumulator)}

  Operation:  $A \land M, M7 \implies N, M6 \implies V$

  Bit 6 and 7 are transferred to the status register.
  If the result of $A \land M$ is zero then Z = 1, otherwise
  Z = 0
  \begin{table}[H]
  \centering                           
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  M7 & / & \_ & \_ & \_ & M6\\
  \hline
  \end{tabular}
  \end{table}
                               (Ref: 4.2.1.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
  Addressing Mode & Assembly Language Form & OP CODE & No. Bytes & No. Cycles\\
  \hline
  Zero Page     &   BIT Oper            &    24   &    2    &    3\\
  Absolute      &   BIT Oper            &    2C   &    3    &    4\\
  \hline
  \end{tabular}
  \end{table}


  \subsection{BMI (BMI Branch on result minus)}

  Operation:  Branch on N = 1
  \begin{table}[H]
  \centering                           
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                               (Ref: 4.1.1.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
  Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
  Relative      &   BMI Oper            &    30   &    2    &    2*\\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if branch occurs to same page.
  * Add 1 if branch occurs to different page.


  \subsection{BNE (BNE Branch on result not zero)}

  Operation:  Branch on Z = 0
  \begin{table}[H]
  \centering                           
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                               (Ref: 4.1.1.6)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
  Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
  Relative      &   BMI Oper            &    D0   &    2    &    2*\\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page.


  \subsection{BPL (BPL Branch on result plus)}

  Operation:  Branch on N = 0
  \begin{table}[H]
  \centering                           
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                               (Ref: 4.1.1.2)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Relative      &   BPL Oper            &    10   &    2    &    2*\\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page.


  \subsection{BRK (BRK Force Break)}

  Operation:  Forced Interrupt PC + 2 toS P toS
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & 1 & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 9.11)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Implied       &   BRK                 &    00   &    1    &    7\\
  \hline
  \end{tabular}
  \end{table}
  1. A BRK command cannot be masked by setting I.


  \subsection{BVC (BVC Branch on overflow clear)}

  Operation:  Branch on V = 0
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                               (Ref: 4.1.1.8)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Relative      &   BVC Oper            &    50   &    2    &    2*\\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page.


  \subsection{BVS (BVS Branch on overflow set)}

  Operation:  Branch on V = 1
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                               (Ref: 4.1.1.7)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Relative      &   BVS Oper            &    70   &    2    &    2*\\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page.


  \subsection{CLC (CLC Clear carry flag)}

  Operation:  $0 \implies C$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & 0 & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                (Ref: 3.0.2)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Implied       &   CLC                 &    18   &    1    &    2\\
  \hline
  \end{tabular}
  \end{table}


  \subsection{CLD (CLD Clear decimal mode)}

  Operation:  $0 \implies D$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&A&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & 0 & \_\\
  \hline
  \end{tabular}
  \end{table}
                                (Ref: 3.3.2)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Implied       &   CLD                 &    D8   &    1    &    2\\
  \hline
  \end{tabular}
  \end{table}


  \subsection{CLI (CLI Clear interrupt disable bit)}

  Operation: $0 \implies I$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & 0 & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                (Ref: 3.2.2)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Implied       &   CLI                 &    58   &    1    &    2\\
  \hline
  \end{tabular}
  \end{table}

  \subsection{CLV (CLV Clear overflow flag)}

  Operation: $0 \implies V$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & 0\\
  \hline
  \end{tabular}
  \end{table}
                                (Ref: 3.6.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Implied       &   CLV                 &    B8   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{CMP (CMP Compare memory and accumulator)}

  Operation:  A - M
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & / & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                (Ref: 4.2.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Immediate     &   CMP \#Oper          &    C9   &    2    &    2     \\
    Zero Page     &   CMP Oper            &    C5   &    2    &    3     \\
    Zero Page,X   &   CMP Oper,X          &    D5   &    2    &    4     \\
    Absolute      &   CMP Oper            &    CD   &    3    &    4     \\
    Absolute,X    &   CMP Oper,X          &    DD   &    3    &    4*    \\
    Absolute,Y    &   CMP Oper,Y          &    D9   &    3    &    4*    \\
    (Indirect,X)  &   CMP (Oper,X)        &    C1   &    2    &    6     \\
    (Indirect),Y  &   CMP (Oper),Y        &    D1   &    2    &    5*    \\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if page boundary is crossed.

  \subsection{CPX (CPX Compare Memory and Index X)}

  Operation:  X - M
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & / & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.8)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Immediate     &   CPX \#Oper          &    E0   &    2    &    2     \\
    Zero Page     &   CPX Oper            &    E4   &    2    &    3     \\
    Absolute      &   CPX Oper            &    EC   &    3    &    4     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{CPY (CPY Compare memory and index Y)}

  Operation:  Y - M
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & / & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.9)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Immediate     &   CPY \#Oper           &    C0   &    2    &    2     \\
    Zero Page     &   CPY Oper            &    C4   &    2    &    3     \\
    Absolute      &   CPY Oper            &    CC   &    3    &    4     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{DEC (DEC Decrement memory by one)}

  Operation:  $M - 1 \implies M$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                   (Ref: 10.7)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Zero Page     &   DEC Oper            &    C6   &    2    &    5     \\
    Zero Page,X   &   DEC Oper,X          &    D6   &    2    &    6     \\
    Absolute      &   DEC Oper            &    CE   &    3    &    6     \\
    Absolute,X    &   DEC Oper,X          &    DE   &    3    &    7     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{DEX (DEX Decrement index X by one)}

  Operation:  $X - 1 \implies X$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.6)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Implied       &   DEX                 &    CA   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{DEY (DEY Decrement index Y by one)}

  Operation:  $X - 1 \implies Y$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.7)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Implied       &   DEY                 &    88   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{EOR (EOR "Exclusive-Or" memory with accumulator)}

  Operation:  $A EOR M \implies A$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                               (Ref: 2.2.3.2)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Immediate     &   EOR \#Oper          &    49   &    2    &    2     \\
    Zero Page     &   EOR Oper            &    45   &    2    &    3     \\
    Zero Page,X   &   EOR Oper,X          &    55   &    2    &    4     \\
    Absolute      &   EOR Oper            &    40   &    3    &    4     \\
    Absolute,X    &   EOR Oper,X          &    50   &    3    &    4*    \\
    Absolute,Y    &   EOR Oper,Y          &    59   &    3    &    4*    \\
    (Indirect,X)  &   EOR (Oper,X)        &    41   &    2    &    6     \\
    (Indirect),Y  &   EOR (Oper),Y        &    51   &    2    &    5*    \\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if page boundary is crossed.

  \subsection{INC (INC Increment memory by one)}

  Operation:  $M + 1 \implies M$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 10.6)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Zero Page     &   INC Oper            &    E6   &    2    &    5     \\
    Zero Page,X   &   INC Oper,X          &    F6   &    2    &    6     \\
    Absolute      &   INC Oper            &    EE   &    3    &    6     \\
    Absolute,X    &   INC Oper,X          &    FE   &    3    &    7     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{INX (INX Increment Index X by one)}

  Operation:  $X + 1 \implies X$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.4)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Implied       &   INX                 &    E8   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{INY (INY Increment Index Y by one)}

  Operation:  $X + 1 \implies X$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                   (Ref: 7.5)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Implied       &   INY                 &    C8   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{JMP (JMP Jump to new location)}

  Operation:  $(PC + 1) -> PCL$
              $(PC + 2) -> PCH$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                (Ref: 4.0.2)
                                (Ref: 9.8.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Absolute      &   JMP Oper            &    4C   &    3    &    3     \\
    Indirect      &   JMP (Oper)          &    6C   &    3    &    5     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{JSR (JSR Jump to new location saving return address)}

  Operation:  $PC + 2 toS, (PC + 1) \implies PCL$
                          $(PC + 2) \implies PCH$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}

                                 (Ref: 8.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Absolute      &   JSR Oper            &    20   &    3    &    6     \\
  \hline
  \end{tabular}
  \end{table}

  LDA                  LDA Load accumulator with memory                 LDA

  Operation:  $M \implies A$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                (Ref: 2.1.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Immediate     &   LDA \#Oper           &    A9   &    2    &    2     \\
    Zero Page     &   LDA Oper            &    A5   &    2    &    3     \\
    Zero Page,X   &   LDA Oper,X          &    B5   &    2    &    4     \\
    Absolute      &   LDA Oper            &    AD   &    3    &    4     \\
    Absolute,X    &   LDA Oper,X          &    BD   &    3    &    4*    \\
    Absolute,Y    &   LDA Oper,Y          &    B9   &    3    &    4*    \\
    (Indirect,X)  &   LDA (Oper,X)        &    A1   &    2    &    6     \\
    (Indirect),Y  &   LDA (Oper),Y        &    B1   &    2    &    5*    \\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 if page boundary is crossed.

  \subsection{LDX (LDX Load index X with memory)}

  Operation:  $M \implies X$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.0)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Immediate     &   LDX \#Oper           &    A2   &    2    &    2     \\
    Zero Page     &   LDX Oper            &    A6   &    2    &    3     \\
    Zero Page,Y   &   LDX Oper,Y          &    B6   &    2    &    4     \\
    Absolute      &   LDX Oper            &    AE   &    3    &    4     \\
    Absolute,Y    &   LDX Oper,Y          &    BE   &    3    &    4*    \\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 when page boundary is crossed.

  \subsection{LDY (LDY Load index Y with memory)}
  
  Operation:  $M \implies Y$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Immediate     &   LDY \#Oper          &    A0   &    2    &    2     \\
    Zero Page     &   LDY Oper            &    A4   &    2    &    3     \\
    Zero Page,X   &   LDY Oper,X          &    B4   &    2    &    4     \\
    Absolute      &   LDY Oper            &    AC   &    3    &    4     \\
    Absolute,X    &   LDY Oper,X          &    BC   &    3    &    4*    \\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 when page boundary is crossed.

  \subsection{LSR (LSR Shift right one bit (memory or accumulator))}

  Operation:  $0 \implies$ \begin{tabular}{|c|c|c|c|c|c|c|c|}\hline7&6&5&4&3&2&1&0\\\hline\end{tabular} $\implies C$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  0 & / & / & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 10.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Accumulator   &   LSR A               &    4A   &    1    &    2     \\
    Zero Page     &   LSR Oper            &    46   &    2    &    5     \\
    Zero Page,X   &   LSR Oper,X          &    56   &    2    &    6     \\
    Absolute      &   LSR Oper            &    4E   &    3    &    6     \\
    Absolute,X    &   LSR Oper,X          &    5E   &    3    &    7     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{NOP (NOP No operation)}
  
  Operation:  No Operation (2 cycles)
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}

  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Implied       &   NOP                 &    EA   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{ORA (ORA "OR" memory with accumulator)}

  Operation: $A \lor M \implies A$
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 2.2.3.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Immediate     &   ORA \#Oper           &    09   &    2    &    2     \\
    Zero Page     &   ORA Oper            &    05   &    2    &    3     \\
    Zero Page,X   &   ORA Oper,X          &    15   &    2    &    4     \\
    Absolute      &   ORA Oper            &    0D   &    3    &    4     \\
    Absolute,X    &   ORA Oper,X          &    1D   &    3    &    4*    \\
    Absolute,Y    &   ORA Oper,Y          &    19   &    3    &    4*    \\
    (Indirect,X)  &   ORA (Oper,X)        &    01   &    2    &    6     \\
    (Indirect),Y  &   ORA (Oper),Y        &    11   &    2    &    5     \\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 on page crossing

  \subsection{PHA (PHA Push accumulator on stack)}

  Operation:  A toS
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 8.5)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Implied       &   PHA                 &    48   &    1    &    3     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{PHP (PHP Push processor status on stack)}

  Operation:  P toS
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 8.11)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
   Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
    Implied       &   PHP                 &    08   &    1    &    3     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{PLA (PLA Pull accumulator from stack)}

  Operation:  A fromS
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 8.6)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   PLA                 &    68   &    1    &    4     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{PLP (PLP Pull processor status from stack)}

  Operation:  P fromS
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \multicolumn{6}{|c|}{From Stack}\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 8.12)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   PLP                 &    28   &    1    &    4     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{ROL (Rotate one bit left (memory or accumulator))}

  %             +------------------------------+
  %             |         M or A               |
  %             |   +-+-+-+-+-+-+-+-+    +-+   |
  %Operation:   +-< |7|6|5|4|3|2|1|0| <- |C| <-+         N Z C I D V
  %                 +-+-+-+-+-+-+-+-+    +-+             / / / _ _ _
  \begin{center}M or A\end{center}
  Operation:
  ...$\Leftarrow$
  \begin{tabular}{|c|c|c|c|c|c|c|c|}
  \hline
  7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
  \hline
  \end{tabular}
  $\Leftarrow$
  \begin{tabular}{|c|}
  \hline
  C \\
  \hline
  \end{tabular}
  $\Leftarrow$...

  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & / & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 10.3)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Accumulator   &   ROL A               &    2A   &    1    &    2     \\
     Zero Page     &   ROL Oper            &    26   &    2    &    5     \\
     Zero Page,X   &   ROL Oper,X          &    36   &    2    &    6     \\
     Absolute      &   ROL Oper            &    2E   &    3    &    6     \\
     Absolute,X    &   ROL Oper,X          &    3E   &    3    &    7     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{ROR (ROR Rotate one bit right (memory or accumulator))}

  %             +------------------------------+
  %             |                              |
  %             |   +-+    +-+-+-+-+-+-+-+-+   |
  %Operation:   +-> |C| -> |7|6|5|4|3|2|1|0| >-+         N Z C I D V
  %                 +-+    +-+-+-+-+-+-+-+-+             / / / _ _ _
  \begin{center}M or A\end{center}
  Operation:
  ...$\Rightarrow$
  \begin{tabular}{|c|}
  \hline
  C \\
  \hline
  \end{tabular}
  $\Rightarrow$
  \begin{tabular}{|c|c|c|c|c|c|c|c|}
  \hline
  7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
  \hline
  \end{tabular}
  $\Rightarrow$...

  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & / & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 10.4)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Accumulator   &   ROR A               &    6A   &    1    &    2     \\
     Zero Page     &   ROR Oper            &    66   &    2    &    5     \\
     Zero Page,X   &   ROR Oper,X          &    76   &    2    &    6     \\
     Absolute      &   ROR Oper            &    6E   &    3    &    6     \\
     Absolute,X    &   ROR Oper,X          &    7E   &    3    &    7     \\
  \hline
  \end{tabular}
  \end{table}

    Note: ROR instruction is available on MCS650X microprocessors after
          June, 1976.


  \subsection{RTI (RTI Return from interrupt)}
  Operation:  P fromS PC fromS
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \multicolumn{6}{|c|}{From Stack}\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 9.6)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   RTI                 &    4D   &    1    &    6     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{RTS (RTS Return from subroutine)}
  Operation:  PC fromS, PC + 1 $\implies$ PC
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 8.2)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   RTS                 &    60   &    1    &    6     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{SBC (SBC Subtract memory from accumulator with borrow)}
  Operation:  A - M - C\textsuperscript{B} $\implies$ A
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & / & \_ & \_ & /\\
  \hline
  \end{tabular}
  \end{table}
    Note:C\textsuperscript{B} = Borrow\\
    (Ref: 2.2.2)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Immediate     &   SBC \#Oper           &    E9   &    2    &    2     \\
     Zero Page     &   SBC Oper            &    E5   &    2    &    3     \\
     Zero Page,X   &   SBC Oper,X          &    F5   &    2    &    4     \\
     Absolute      &   SBC Oper            &    ED   &    3    &    4     \\
     Absolute,X    &   SBC Oper,X          &    FD   &    3    &    4*    \\
     Absolute,Y    &   SBC Oper,Y          &    F9   &    3    &    4*    \\
     (Indirect,X)  &   SBC (Oper,X)        &    E1   &    2    &    6     \\
     (Indirect),Y  &   SBC (Oper),Y        &    F1   &    2    &    5     \\
  \hline
  \end{tabular}
  \end{table}
  * Add 1 when page boundary is crossed.


  \subsection{SEC (SEC Set carry flag)}
  Operation:  1 $\implies$ C
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & 1 & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                (Ref: 3.0.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   SEC                 &    38   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{SED (SED Set decimal mode)}
  Operation:  1 $\implies$ D
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & 1 & \_\\
  \hline
  \end{tabular}
  \end{table}
                                (Ref: 3.3.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   SED                 &    F8   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{SEI (SEI Set interrupt disable status)}
  Operation:  1 $\implies$ I
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & 1 & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                (Ref: 3.2.1)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   SEI                 &    78   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{STA (STA Store accumulator in memory)}
  Operation:  A $\implies$ M
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                (Ref: 2.1.2)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Zero Page     &   STA Oper            &    85   &    2    &    3     \\
     Zero Page,X   &   STA Oper,X          &    95   &    2    &    4     \\
     Absolute      &   STA Oper            &    80   &    3    &    4     \\
     Absolute,X    &   STA Oper,X          &    90   &    3    &    5     \\
     Absolute,Y    &   STA Oper, Y         &    99   &    3    &    5     \\
     (Indirect,X)  &   STA (Oper,X)        &    81   &    2    &    6     \\
     (Indirect),Y  &   STA (Oper),Y        &    91   &    2    &    6     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{STX (STX Store index X in memory)}
  Operation: X $\implies$ M
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.2)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Zero Page     &   STX Oper            &    86   &    2    &    3     \\
     Zero Page,Y   &   STX Oper,Y          &    96   &    2    &    4     \\
     Absolute      &   STX Oper            &    8E   &    3    &    4     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{STY (STY Store index Y in memory)}
  Operation: Y $\implies$ M
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.3)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Zero Page     &   STY Oper            &    84   &    2    &    3     \\
     Zero Page,X   &   STY Oper,X          &    94   &    2    &    4     \\
     Absolute      &   STY Oper            &    8C   &    3    &    4     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{TAX (TAX Transfer accumulator to index X)}
  Operation:  A $\implies$ X
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.11)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   TAX                 &    AA   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{TAY (TAY Transfer accumulator to index Y)}
  Operation:  A $\implies$ Y
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.13)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   TAY                 &    A8   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{TSX (TSX Transfer stack pointer to index X)}
  Operation:  S $\implies$ X
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 8.9)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   TSX                 &    BA   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{TXA (TXA Transfer index X to accumulator)}
  Operation:  X $\implies$ A
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.12)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   TXA                 &    8A   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}

  \subsection{TXS (TXS Transfer index X to stack pointer)}
  Operation:  X $\implies$ S
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  \_ & \_ & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 8.8)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   TXS                 &    9A   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}


  \subsection{TYA (TYA Transfer index Y to accumulator)}
  Operation:  Y $\implies$ A
  \begin{table}[H]
  \centering
  \begin{tabular}{|c c c c c c|}
  \hline
  N&Z&C&I&D&V\\
  \hline
  / & / & \_ & \_ & \_ & \_\\
  \hline
  \end{tabular}
  \end{table}
                                 (Ref: 7.14)
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|l|c|c|c|}
  \hline
    Addressing Mode& Assembly Language Form& OP CODE &No. Bytes&No. Cycles\\
  \hline
     Implied       &   TYA                 &    98   &    1    &    2     \\
  \hline
  \end{tabular}
  \end{table}


%  +------------------------------------------------------------------------
%  | INSTRUCTION ADDRESSING MODES AND RELATED EXECUTION TIMES
%  | (in clock cycles)
%  +------------------------------------------------------------------------
  \section{General instruction set overview}
  \subsection{Instruction addressing modes and related execution times (in clock cycles)}
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|c c c c c c c c c c c c c c|}
  \hline
               &  A & A & A & B & B & B & B & B & B & B & B & B & B & C\\
               &  D & N & S & C & C & E & I & M & N & P & R & V & V & L\\
               &  C & D & L & C & S & Q & T & I & E & L & K & C & S & C\\
  \hline
  Accumulator  &  . & . & 2 & . & . & . & . & . & . & . & . & . & . & .\\
  Immediate    &  2 & 2 &  &  . & . & . & . & . & . & . & . & . & . & .\\
  Zero Page    &  3 & 3 & 5 & . & . & . & 3 & . & . & . & . & . & . & .\\
  Zero Page,X  &  4 & 4 & 6 & . & . & . & . & . & . & . & . & . & . & .\\
  Zero Page,Y  &  . & . & . & . & . & . & . & . & . & . & . & . & . & .\\
  Absolute     &  4 & 4 & 6 & . & . & . & 4 & . & . & . & . & . & . & .\\
  Absolute,X   &  4*& 4*& 7 & . & . & . & . & . & . & . & . & . & . & .\\
  Absolute,Y   &  4*& 4*& . & . & . & . & . & . & . & . & . & . & . & .\\
  Implied      &  . & . & . & . & . & . & . & . & . & . & . & . & . & 2\\
  Relative     &  . & . & . & 2**&2**&2**&. & 2**&2**&2**&7 & 2**&2**&.\\
  (Indirect,X) &  6 & 6 & . & . & . & . & . & . & . & . & . & . & . & .\\
  (Indirect),Y &  5*& 5*& . & . & . & . & . & . & . & . & . & . & . & .\\
  Abs. Indirect&  . & . & . & . & . & . & . & . & . & . & . & . & . & .\\
  \hline
  \end{tabular}
  \end{table}
  
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|c c c c c c c c c c c c c c|}
  \hline
               &  C & C & C & C & C & C & D & D & D & E & I & I & I & J\\
               &  L & L & L & M & P & P & E & E & E & O & N & N & N & M\\
               &  D & I & V & P & X & Y & C & X & Y & R & C & X & Y & P\\
  \hline
  Accumulator  &  . & . & . & . & . & . & . & . & . & . & . & . & . & .\\
  Immediate    &  . & . & . & 2 & 2 & 2 & . & . & . & 2 & . & . & . & .\\
  Zero Page    &  . & . & . & 3 & 3 & 3 & 5 & . & . & 3 & 5 & . & . & .\\
  Zero Page,X  &  . & . & . & 4 & . & . & 6 & . & . & 4 & 6 & . & . & .\\
  Zero Page,Y  &  . & . & . & . & . & . & . & . & . & . & . & . & . & .\\
  Absolute     &  . & . & . & 4 & 4 & 4 & 6 & . & . & 4 & 6 & . & . & 3\\
  Absolute,X   &  . & . & . & 4*& . & . & 7 & . & . & 4*& 7 & . & . & .\\
  Absolute,Y   &  . & . & . & 4*& . & . & . & . & . & 4*& . & . & . & .\\
  Implied      &  2 & 2 & 2 & . & . & . & . & 2 & 2 & . & . & 2 & 2 & .\\
  Relative     &  . & . & . & . & . & . & . & . & . & . & . & . & . & .\\
  (Indirect,X) &  . & . & . & 6 & . & . & . & . & . & 6 & . & . & . & .\\
  (Indirect),Y &  . & . & . & 5*& . & . & . & . & . & 5*& . & . & . & .\\
  Abs. Indirect&  . & . & . & . & . & . & . & . & . & . & . & . & . & 5\\
  \hline
  \end{tabular}
  \end{table}
     *  Add one cycle if indexing across page boundary
     ** Add one cycle if branch is taken, Add one additional if branching
        operation crosses page boundary


  %------------------------------------------------------------------------+
  %  INSTRUCTION ADDRESSING MODES AND RELATED EXECUTION TIMES              |
  %  (in clock cycles)                                                     |
  %------------------------------------------------------------------------+
  \begin{table}[H]
  \centering
  \begin{tabular}{|l|c c c c c c c c c c c c c c|}
  \hline
                  J & L & L & L & L & N & O & P & P & P & P & R & R & R\\
                  S & D & D & D & S & O & R & H & H & L & L & O & O & T\\
                  R & A & X & Y & R & P & A & A & P & A & P & L & R & I\\
  \hline
  Accumulator  &  . & . & . & . & 2 & . & . & . & . & . & . & 2 & 2 & .\\
  Immediate    &  . & 2 & 2 & 2 & . & . & 2 & . & . & . & . & . & . & .\\
  Zero Page    &  . & 3 & 3 & 3 & 5 & . & 3 & . & . & . & . & 5 & 5 & .\\
  Zero Page,X  &  . & 4 & . & 4 & 6 & . & 4 & . & . & . & . & 6 & 6 & .\\
  Zero Page,Y  &  . & . & 4 & . & . & . & . & . & . & . & . & . & . & .\\
  Absolute     &  6 & 4 & 4 & 4 & 6 & . & 4 & . & . & . & . & 6 & 6 & .\\
  Absolute,X   &  . & 4*& . & 4*& 7 & . & 4*& . & . & . & . & 7 & 7 & .\\
  Absolute,Y   &  . & 4*& 4*& . & . & . & 4*& . & . & . & . & . & . & .\\
  Implied      &  . & . & . & . & . & 2 & . & 3 & 3 & 4 & 4 & . & . & 6\\
  Relative     &  . & . & . & . & . & . & . & . & . & . & . & . & . & .\\
  (Indirect,X) &  . & 6 & . & . & . & . & 6 & . & . & . & . & . & . & .\\
  (Indirect),Y &  . & 5*& . & . & . & . & 5*& . & . & . & . & . & . & .\\
  Abs. Indirect&  . & . & . & . & . & . & . & . & . & . & . & . & . & .\\
  \hline
  \end{tabular}
  \end{table}

  \begin{table}[H]
  \centering
  \begin{tabular}{|l|c c c c c c c c c c c c c c|}
  \hline
               &  R & S & S & S & S & S & S & S & T & T & T & T & T & T\\
               &  T & B & E & E & E & T & T & T & A & A & S & X & X & Y\\
               &  S & C & C & D & I & A & X & Y & X & Y & X & A & S & A\\
  \hline
  Accumulator  &  . & . & . & . & . & . & . & . & . & . & . & . & . & .\\
  Immediate    &  . & 2 & . & . & . & . & . & . & . & . & . & . & . & .\\
  Zero Page    &  . & 3 & . & . & . & 3 & 3 & 3 & . & . & . & . & . & .\\
  Zero Page,X  &  . & 4 & . & . & . & 4 & . & 4 & . & . & . & . & . & .\\
  Zero Page,Y  &  . & . & . & . & . & . & 4 & . & . & . & . & . & . & .\\
  Absolute     &  . & 4 & . & . & . & 4 & 4 & 4 & . & . & . & . & . & .\\
  Absolute,X   &  . & 4*& . & . & . & 5 & . & . & . & . & . & . & . & .\\
  Absolute,Y   &  . & 4*& . & . & . & 5 & . & . & . & . & . & . & . & .\\
  Implied      &  6 & . & 2 & 2 & 2 & . & . & . & 2 & 2 & 2 & 2 & 2 & 2\\
  Relative     &  . & . & . & . & . & . & . & . & . & . & . & . & . & .\\
  (Indirect,X) &  . & 6 & . & . & . & 6 & . & . & . & . & . & . & . & .\\
  (Indirect),Y &  . & 5*& . & . & . & 6 & . & . & . & . & . & . & . & .\\
  Abs. Indirect&  . & . & . & . & . & . & . & . & . & . & . & . & . & .\\
  \hline
  \end{tabular}
  \end{table}
     *  Add one cycle if indexing across page boundary
     ** Add one cycle if branch is taken, Add one additional if branching
        operation crosses page boundary

\subsection{Instruction set ordered by opcode}
\setlength{\columnsep}{-1cm}
  \begin{multicols}{2}
  \begin{enumerate}[label=\enumHex*,start=0]
    \item[00] 00 - BRK                        
    \item[01] 01 - ORA - (Indirect,X)         
    \item[02] 02 - Future Expansion           
    \item[03] 03 - Future Expansion           
    \item[04] 04 - Future Expansion           
    \item[05] 05 - ORA - Zero Page            
    \item[06] 06 - ASL - Zero Page            
    \item[07] 07 - Future Expansion           
    \item[08] 08 - PHP                        
    \item[09] 09 - ORA - Immediate            
    \item[0A] 0A - ASL - Accumulator          
    \item[0B] 0B - Future Expansion           
    \item[0C] 0C - Future Expansion           
    \item[0D] 0D - ORA - Absolute             
    \item[0E] 0E - ASL - Absolute             
    \item[0F] 0F - Future Expansion 
    \setcounter{enumi}{15}          
    \item 10 - BPL                        
    \item 11 - ORA - (Indirect),Y         
    \item 12 - Future Expansion           
    \item 13 - Future Expansion           
    \item 14 - Future Expansion           
    \item 15 - ORA - Zero Page,X          
    \item 16 - ASL - Zero Page,X          
    \item 17 - Future Expansion           
    \item 18 - CLC                        
    \item 19 - ORA - Absolute,Y           
    \item 1A - Future Expansion           
    \item 1B - Future Expansion           
    \item 1C - Future Expansion           
    \item 1D - ORA - Absolute,X           
    \item 1E - ASL - Absolute,X           
    \item 1F - Future Expansion           
    \item 20 - JSR
    \item 21 - AND - (Indirect,X)
    \item 22 - Future Expansion
    \item 23 - Future Expansion
    \item 24 - BIT - Zero Page
    \item 25 - AND - Zero Page
    \item 26 - ROL - Zero Page
    \item 27 - Future Expansion
    \item 28 - PLP
    \item 29 - AND - Immediate
    \item 2A - ROL - Accumulator
    \item 2B - Future Expansion
    \item 2C - BIT - Absolute
    \item 2D - AND - Absolute
    \item 2E - ROL - Absolute
    \item 2F - Future Expansion
    \item 30 - BMI
    \item 31 - AND - (Indirect),Y
    \item 32 - Future Expansion
    \item 33 - Future Expansion
    \item 34 - Future Expansion
    \item 35 - AND - Zero Page,X
    \item 36 - ROL - Zero Page,X
    \item 37 - Future Expansion
    \item 38 - SEC
    \item 39 - AND - Absolute,Y
    \item 3A - Future Expansion
    \item 3B - Future Expansion
    \item 3C - Future Expansion
    \item 3D - AND - Absolute,X
    \item 3E - ROL - Absolute,X
    \item 3F - Future Expansion

    \item 40 - RTI                        
    \item 41 - EOR - (Indirect,X)         
    \item 42 - Future Expansion           
    \item 43 - Future Expansion           
    \item 44 - Future Expansion           
    \item 45 - EOR - Zero Page            
    \item 46 - LSR - Zero Page            
    \item 47 - Future Expansion           
    \item 48 - PHA                        
    \item 49 - EOR - Immediate            
    \item 4A - LSR - Accumulator          
    \item 4B - Future Expansion           
    \item 4C - JMP - Absolute             
    \item 4D - EOR - Absolute             
    \item 4E - LSR - Absolute             
    \item 4F - Future Expansion           
    \item 50 - BVC                        
    \item 51 - EOR - (Indirect),Y         
    \item 52 - Future Expansion           
    \item 53 - Future Expansion           
    \item 54 - Future Expansion           
    \item 55 - EOR - Zero Page,X          
    \item 56 - LSR - Zero Page,X          
    \item 57 - Future Expansion           
    \item 58 - CLI                        
    \item 59 - EOR - Absolute,Y           
    \item 5A - Future Expansion           
    \item 5B - Future Expansion           
    \item 5C - Future Expansion           
    \item 50 - EOR - Absolute,X           
    \item 5E - LSR - Absolute,X           
    \item 5F - Future Expansion           
    \item 60 - RTS
    \item 61 - ADC - (Indirect,X)
    \item 62 - Future Expansion
    \item 63 - Future Expansion
    \item 64 - Future Expansion
    \item 65 - ADC - Zero Page
    \item 66 - ROR - Zero Page
    \item 67 - Future Expansion
    \item 68 - PLA
    \item 69 - ADC - Immediate
    \item 6A - ROR - Accumulator
    \item 6B - Future Expansion
    \item 6C - JMP - Indirect
    \item 6D - ADC - Absolute
    \item 6E - ROR - Absolute
    \item 6F - Future Expansion
    \item 70 - BVS
    \item 71 - ADC - (Indirect),Y
    \item 72 - Future Expansion
    \item 73 - Future Expansion
    \item 74 - Future Expansion
    \item 75 - ADC - Zero Page,X
    \item 76 - ROR - Zero Page,X
    \item 77 - Future Expansion
    \item 78 - SEI
    \item 79 - ADC - Absolute,Y
    \item 7A - Future Expansion
    \item 7B - Future Expansion
    \item 7C - Future Expansion
    \item 70 - ADC - Absolute,X
    \item 7E - ROR - Absolute,X
    \item 7F - Future Expansion

    \item 80 - Future Expansion           
    \item 81 - STA - (Indirect,X)         
    \item 82 - Future Expansion           
    \item 83 - Future Expansion           
    \item 84 - STY - Zero Page            
    \item 85 - STA - Zero Page            
    \item 86 - STX - Zero Page            
    \item 87 - Future Expansion           
    \item 88 - DEY                        
    \item 89 - Future Expansion           
    \item 8A - TXA                        
    \item 8B - Future Expansion           
    \item 8C - STY - Absolute             
    \item 80 - STA - Absolute             
    \item 8E - STX - Absolute             
    \item 8F - Future Expansion           
    \item 90 - BCC                        
    \item 91 - STA - (Indirect),Y         
    \item 92 - Future Expansion           
    \item 93 - Future Expansion           
    \item 94 - STY - Zero Page,X          
    \item 95 - STA - Zero Page,X          
    \item 96 - STX - Zero Page,Y          
    \item 97 - Future Expansion           
    \item 98 - TYA                        
    \item 99 - STA - Absolute,Y           
    \item 9A - TXS                        
    \item 9B - Future Expansion           
    \item 9C - Future Expansion           
    \item 90 - STA - Absolute,X           
    \item 9E - Future Expansion           
    \item 9F - Future Expansion           
    \item A0 - LDY - Immediate
    \item A1 - LDA - (Indirect,X)
    \item A2 - LDX - Immediate
    \item A3 - Future Expansion
    \item A4 - LDY - Zero Page
    \item A5 - LDA - Zero Page
    \item A6 - LDX - Zero Page
    \item A7 - Future Expansion
    \item A8 - TAY
    \item A9 - LDA - Immediate
    \item AA - TAX
    \item AB - Future Expansion
    \item AC - LDY - Absolute
    \item AD - LDA - Absolute
    \item AE - LDX - Absolute
    \item AF - Future Expansion
    \item B0 - BCS
    \item B1 - LDA - (Indirect),Y
    \item B2 - Future Expansion
    \item B3 - Future Expansion
    \item B4 - LDY - Zero Page,X
    \item BS - LDA - Zero Page,X
    \item B6 - LDX - Zero Page,Y
    \item B7 - Future Expansion
    \item B8 - CLV
    \item B9 - LDA - Absolute,Y
    \item BA - TSX
    \item BB - Future Expansion
    \item BC - LDY - Absolute,X
    \item BD - LDA - Absolute,X
    \item BE - LDX - Absolute,Y
    \item BF - Future Expansion

    \item C0 - Cpy - Immediate            
    \item C1 - CMP - (Indirect,X)         
    \item C2 - Future Expansion           
    \item C3 - Future Expansion           
    \item C4 - CPY - Zero Page            
    \item C5 - CMP - Zero Page            
    \item C6 - DEC - Zero Page            
    \item C7 - Future Expansion           
    \item C8 - INY                        
    \item C9 - CMP - Immediate            
    \item CA - DEX                        
    \item CB - Future Expansion           
    \item CC - CPY - Absolute             
    \item CD - CMP - Absolute             
    \item CE - DEC - Absolute             
    \item CF - Future Expansion           
    \item D0 - BNE                        
    \item D1 - CMP   (Indirect@,Y         
    \item D2 - Future Expansion           
    \item D3 - Future Expansion           
    \item D4 - Future Expansion           
    \item D5 - CMP - Zero Page,X          
    \item D6 - DEC - Zero Page,X          
    \item D7 - Future Expansion           
    \item D8 - CLD                        
    \item D9 - CMP - Absolute,Y           
    \item DA - Future Expansion           
    \item DB - Future Expansion           
    \item DC - Future Expansion           
    \item DD - CMP - Absolute,X           
    \item DE - DEC - Absolute,X           
    \item DF - Future Expansion           
    \item E0 - CPX - Immediate
    \item E1 - SBC - (Indirect,X)
    \item E2 - Future Expansion
    \item E3 - Future Expansion
    \item E4 - CPX - Zero Page
    \item E5 - SBC - Zero Page
    \item E6 - INC - Zero Page
    \item E7 - Future Expansion
    \item E8 - INX
    \item E9 - SBC - Immediate
    \item EA - NOP
    \item EB - Future Expansion
    \item EC - CPX - Absolute
    \item ED - SBC - Absolute
    \item EE - INC - Absolute
    \item EF - Future Expansion
    \item F0 - BEQ
    \item F1 - SBC - (Indirect),Y
    \item F2 - Future Expansion
    \item F3 - Future Expansion
    \item F4 - Future Expansion
    \item F5 - SBC - Zero Page,X
    \item F6 - INC - Zero Page,X
    \item F7 - Future Expansion
    \item F8 - SED
    \item F9 - SBC - Absolute,Y
    \item FA - Future Expansion
    \item FB - Future Expansion
    \item FC - Future Expansion
    \item FD - SBC - Absolute,X
    \item FE - INC - Absolute,X
    \item FF - Future Expansion
  \end{enumerate}
  \end{multicols}
\end{document}

INSTRUCTION OPERATION

 The following code has been taken from VICE for the purposes of showing
how each instruction operates. No particular addressing mode is used since
we only wish to see the operation of the instruction itself. 

     src : the byte of data that is being addressed.
     SET_SIGN : sets\resets the sign flag depending on bit 7.
     SET_ZERO : sets\resets the zero flag depending on whether the result
                is zero or not.
     SET_CARRY(condition) : if the condition has a non-zero value then the
                carry flag is set, else it is reset.
     SET_OVERFLOW(condition) : if the condition is true then the overflow
                flag is set, else it is reset.
     SET_INTERRUPT :  }
     SET_BREAK :      }  As for SET_CARRY and SET_OVERFLOW.
     SET_DECIMAL :    }
     REL_ADDR(PC, src) : returns the relative address obtained by adding
                the displacement src to the PC.
     SET_SR : set the Program Status Register to the value given.
     GET_SR : get the value of the Program Status Register.
     PULL : Pull a byte off the stack.
     PUSH : Push a byte onto the stack.
     LOAD : Get a byte from the memory address.
     STORE : Store a byte in a memory address.
     IF_CARRY, IF_OVERFLOW, IF_SIGN, IF_ZERO etc : Returns true if the
                relevant flag is set, otherwise returns false.
     clk : the number of cycles an instruction takes. This is shown below
                in situations where the number of cycles changes depending
                on the result of the instruction (eg. Branching instructions).

     AC = Accumulator
     XR = X register
     YR = Y register
     PC = Program Counter
     SP = Stack Pointer


/* ADC */
    unsigned int temp = src + AC + (IF_CARRY() ? 1 : 0);
    SET_ZERO(temp & 0xff);	/* This is not valid in decimal mode */
    if (IF_DECIMAL()) {
        if (((AC & 0xf) + (src & 0xf) + (IF_CARRY() ? 1 : 0)) > 9) temp += 6;
	SET_SIGN(temp);
	SET_OVERFLOW(!((AC ^ src) & 0x80) && ((AC ^ temp) & 0x80));
	if (temp > 0x99) temp += 96;
	SET_CARRY(temp > 0x99);
    } else {
	SET_SIGN(temp);
	SET_OVERFLOW(!((AC ^ src) & 0x80) && ((AC ^ temp) & 0x80));
	SET_CARRY(temp > 0xff);
    }
    AC = ((BYTE) temp);

/* AND */
    src &= AC;
    SET_SIGN(src);
    SET_ZERO(src);
    AC = src;

/* ASL */
    SET_CARRY(src & 0x80);
    src <<= 1;
    src &= 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    STORE src in memory or accumulator depending on addressing mode.

/* BCC */
    if (!IF_CARRY()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

/* BCS */
    if (IF_CARRY()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

/* BEQ */
    if (IF_ZERO()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

/* BIT */
    SET_SIGN(src);
    SET_OVERFLOW(0x40 & src);	/* Copy bit 6 to OVERFLOW flag. */
    SET_ZERO(src & AC);

/* BMI */
    if (IF_SIGN()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

/* BNE */
    if (!IF_ZERO()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

/* BPL */
    if (!IF_SIGN()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

/* BRK */
    PC++;
    PUSH((PC >> 8) & 0xff);	/* Push return address onto the stack. */
    PUSH(PC & 0xff);
    SET_BREAK((1));             /* Set BFlag before pushing */
    PUSH(SR);
    SET_INTERRUPT((1));
    PC = (LOAD(0xFFFE) | (LOAD(0xFFFF) << 8));

/* BVC */
    if (!IF_OVERFLOW()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

/* BVS */
    if (IF_OVERFLOW()) {
	clk += ((PC & 0xFF00) != (REL_ADDR(PC, src) & 0xFF00) ? 2 : 1);
	PC = REL_ADDR(PC, src);
    }

/* CLC */
    SET_CARRY((0));

/* CLD */
    SET_DECIMAL((0));

/* CLI */
    SET_INTERRUPT((0));

/* CLV */
    SET_OVERFLOW((0));

/* CMP */
    src = AC - src;
    SET_CARRY(src < 0x100);
    SET_SIGN(src);
    SET_ZERO(src &= 0xff);

/* CPX */
    src = XR - src;
    SET_CARRY(src < 0x100);
    SET_SIGN(src);
    SET_ZERO(src &= 0xff);

/* CPY */
    src = YR - src;
    SET_CARRY(src < 0x100);
    SET_SIGN(src);
    SET_ZERO(src &= 0xff);

/* DEC */
    src = (src - 1) & 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    STORE(address, (src));

/* DEX */
    unsigned src = XR;
    src = (src - 1) & 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    XR = (src);

/* DEY */
    unsigned src = YR;
    src = (src - 1) & 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    YR = (src);

/* EOR */
    src ^= AC;
    SET_SIGN(src);
    SET_ZERO(src);
    AC = src;

/* INC */
    src = (src + 1) & 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    STORE(address, (src));

/* INX */
    unsigned src = XR;
    src = (src + 1) & 0xff;
    SET_SIGN(src);
    SET_ZERO(src); 
    XR = (src);

/* INY */
    unsigned src = YR;
    src = (src + 1) & 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    YR = (src);

/* JMP */
    PC = (src);

/* JSR */
    PC--;
    PUSH((PC >> 8) & 0xff);	/* Push return address onto the stack. */
    PUSH(PC & 0xff);
    PC = (src);

/* LDA */
    SET_SIGN(src);
    SET_ZERO(src);
    AC = (src);

/* LDX */
    SET_SIGN(src);
    SET_ZERO(src);
    XR = (src);

/* LDY */
    SET_SIGN(src);
    SET_ZERO(src);
    YR = (src);

/* LSR */
    SET_CARRY(src & 0x01);
    src >>= 1;
    SET_SIGN(src);
    SET_ZERO(src);
    STORE src in memory or accumulator depending on addressing mode.

/* NOP */
    Nothing.

/* ORA */
    src |= AC;
    SET_SIGN(src);
    SET_ZERO(src);
    AC = src;

/* PHA */
    src = AC;
    PUSH(src);

/* PHP */
    src = GET_SR;
    PUSH(src);

/* PLA */
    src = PULL();
    SET_SIGN(src);	/* Change sign and zero flag accordingly. */
    SET_ZERO(src);

/* PLP */
    src = PULL();
    SET_SR((src));

/* ROL */
    src <<= 1;
    if (IF_CARRY()) src |= 0x1;
    SET_CARRY(src > 0xff);
    src &= 0xff;
    SET_SIGN(src);
    SET_ZERO(src);
    STORE src in memory or accumulator depending on addressing mode.

/* ROR */
    if (IF_CARRY()) src |= 0x100;
    SET_CARRY(src & 0x01);
    src >>= 1;
    SET_SIGN(src);
    SET_ZERO(src);
    STORE src in memory or accumulator depending on addressing mode.

/* RTI */
    src = PULL();
    SET_SR(src);
    src = PULL();
    src |= (PULL() << 8);	/* Load return address from stack. */
    PC = (src);

/* RTS */
    src = PULL();
    src += ((PULL()) << 8) + 1;	/* Load return address from stack and add 1. */
    PC = (src);

/* SBC */
    unsigned int temp = AC - src - (IF_CARRY() ? 0 : 1);
    SET_SIGN(temp);
    SET_ZERO(temp & 0xff);	/* Sign and Zero are invalid in decimal mode */
    SET_OVERFLOW(((AC ^ temp) & 0x80) && ((AC ^ src) & 0x80));
    if (IF_DECIMAL()) {
	if ( ((AC & 0xf) - (IF_CARRY() ? 0 : 1)) < (src & 0xf)) /* EP */ temp -= 6;
	if (temp > 0x99) temp -= 0x60;
    }
    SET_CARRY(temp < 0x100);
    AC = (temp & 0xff);

/* SEC */
    SET_CARRY((1));

/* SED */
    SET_DECIMAL((1));

/* SEI */
    SET_INTERRUPT((1));

/* STA */
    STORE(address, (src));

/* STX */
    STORE(address, (src));

/* STY */
    STORE(address, (src));

/* TAX */
    unsigned src = AC;
    SET_SIGN(src);
    SET_ZERO(src);
    XR = (src);

/* TAY */
    unsigned src = AC;
    SET_SIGN(src);
    SET_ZERO(src);
    YR = (src);

/* TSX */
    unsigned src = SP;
    SET_SIGN(src);
    SET_ZERO(src);
    XR = (src);

/* TXA */
    unsigned src = XR;
    SET_SIGN(src);
    SET_ZERO(src);
    AC = (src);

/* TXS */
    unsigned src = XR;
    SP = (src);

/* TYA */
    unsigned src = YR;
    SET_SIGN(src);
    SET_ZERO(src);
    AC = (src);
%\end{document}